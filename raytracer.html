<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.4/chai.min.js"
        integrity="sha512-gkZWobgJrQevN2HMEeTnSlxWPJ3HS0JJ3nXcgI6XLK/NI0z59jbztRZqbTlIzfl21vIGahQaeW0knwH1az/tbg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <title>Raytracer</title>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        // ************************ TUPLE ***********************************************************
        const EPSILON = 0.00001;

        function equal(a, b) {
            return Math.abs(a - b) < EPSILON;
        }

        function tuple(x, y, z, w) {
            return { x, y, z, w };
        }

        function point(x, y, z) {
            return { x, y, z, w: 1 };
        }

        function vector(x, y, z) {
            return { x, y, z, w: 0 }
        }

        function add_tuple(a, b) {
            return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z, w: a.w + b.w };
        }

        function sub_tuple(a, b) {
            return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z, w: a.w - b.w };
        }
        function negate(t) {
            return { x: -t.x, y: -t.y, z: -t.z, w: -t.w };
        }
        function multiply_tuple(t, s) {
            return { x: t.x * s, y: t.y * s, z: t.z * s, w: t.w * s };
        }
        function divide_tuple(t, s) {
            return { x: t.x / s, y: t.y / s, z: t.z / s, w: t.w / s };
        }
        function magnitude(t) {
            return Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w);
        }
        function normalize(t) {
            const m = magnitude(t);
            return divide_tuple(t, m);
        }
        function dot(t, a) {
            return a.x * t.x + a.y * t.y + a.z * t.z + a.w * t.w;
        }
        function cross(t, b) {
            return vector(t.y * b.z - t.z * b.y,
                t.z * b.x - t.x * b.z,
                t.x * b.y - t.y * b.x);

        }
        function reflect(t, normal) {
            return sub_tuple(t, multiply_tuple(normal, 2 * dot(t, normal)));

        }
        function equal_tuple(a, b) {
            return equal(a.x, b.x) && equal(a.y, b.y) && equal(a.z, b.z) && equal(a.w, b.w);
        }

        /*************** COLOR ************************************************************/

        function color(r, g, b) {
            return { red: r, green: g, blue: b };
        }

        function add_color(a, b) {
            return { red: a.red + b.red, green: a.green + b.green, blue: a.blue + b.blue };
        }
        function sub_color(a, b) {
            return { red: a.red - b.red, green: a.green - b.green, blue: a.blue - b.blue };
        }
        function multiply_color(a, k) {
            return { red: a.red * k, green: a.green * k, blue: a.blue * k };
        }
        function hadamard_color(a, b) {
            return { red: a.red * b.red, green: a.green * b.green, blue: a.blue * b.blue };

        }

        /************* CANVAS ***********************************************************/

        function canvas(width, height) {


            return { width: width, height: height, pixels: new Array(width * height).fill(color(0, 0, 0)) };
        }

        function init_canvas(sel, width, height) {
            const c = document.querySelector(sel);
            c.width = width;
            c.height = height;
            const ctx = c.getContext('2d');
            const data = ctx.getImageData(0, 0, width, height);
            for (let i = 0; i < width * height; i++) {
                data.data[i * 4 + 3] = 255;
            }
            return { canvas: c, ctx: ctx, data: data };

        }

        function write_pixel(canvas, x, y, color) {
            canvas.pixels[canvas.width * y + x] = color;
        }
        function pixel_at(canvas, x, y) {
            return canvas.pixels[canvas.width * y + x];
        }

        function draw_pixel(canvas, x, y, color, update = false) {
            const r = Math.floor(color.red * 255.999);
            const g = Math.floor(color.green * 255.999);
            const b = Math.floor(color.blue * 255.999);
            const off = (x + y * canvas.data.width) * 4;
            canvas.data.data[off] = r;
            canvas.data.data[off + 1] = g;
            canvas.data.data[off + 2] = b;
            canvas.data.data[off + 3] = 255;
            // console.log(color);
            if (update) {
                canvas.ctx.putImageData(0, 0, canvas.data);
            }

        }
        function update_canvas(canvas) {
            canvas.ctx.putImageData(canvas.data, 0, 0);
        }
        function read_pixel(canvas, x, y) {
            return { red: 0, green: 0, blue: 0 };
        }

        /***************  MATRIX ****************************/
        function matrix() {
            return [
                [0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0]
            ];
        }

        function identity() {
            return [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ]
        }

        function matrix_from_array(a) {
            return [
                [a[0], a[1], a[2], a[3]],
                [a[4], a[5], a[6], a[7]],
                [a[8], a[9], a[10], a[11]],
                [a[12], a[13], a[14], a[15]]
            ];
        }

        function translation(x, y, z) {
            return [
                [1.0, 0.0, 0.0, x],
                [0.0, 1.0, 0.0, y],
                [0.0, 0.0, 1.0, z],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }

        function scaling(x, y, z) {
            return [
                [x, 0.0, 0.0, 0.0],
                [0.0, y, 0.0, 0.0],
                [0.0, 0.0, z, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }
        function rotation_x(r) {
            const c = Math.cos(r);
            const s = Math.sin(r);
            return [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, c, -s, 0.0],
                [0.0, s, c, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }
        function rotation_y(r) {
            const c = Math.cos(r);
            const s = Math.sin(r);
            return [
                [c, 0.0, s, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [-s, 0.0, c, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }
        function rotation_z(r) {
            const c = Math.cos(r);
            const s = Math.sin(r);
            return [
                [c, -s, 0.0, 0.0],
                [s, c, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }
        function shearing(xy, xz, yx, yz, zx, zy) {
            return [
                [1.0, xy, xz, 0.0],
                [yx, 1.0, yz, 0.0],
                [zx, zy, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0]
            ];
        }

        function matrix_multiply(a, b) {
            const m = matrix();
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    m[j][i] = a[j][0] * b[0][i]
                        + a[j][1] * b[1][i]
                        + a[j][2] * b[2][i]
                        + a[j][3] * b[3][i];
                }
            }

            return m;

        }

        function matrix_mul_tuple(a, b) {
            const x = a[0][0] * b.x + a[0][1] * b.y + a[0][2] * b.z + a[0][3] * b.w;
            const y = a[1][0] * b.x + a[1][1] * b.y + a[1][2] * b.z + a[1][3] * b.w;
            const z = a[2][0] * b.x + a[2][1] * b.y + a[2][2] * b.z + a[2][3] * b.w;
            const w = a[3][0] * b.x + a[3][1] * b.y + a[3][2] * b.z + a[3][3] * b.w;
            return [x, y, z, w];
        }

        function transpose(a) {
            const v = Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {

                    v[j * 4 + i] = a[i][j];
                }
            }
            return matrix_from_array(v);

        }

        function submatrix(a, row, col) {
            // console.log(a, row, col);

            const v = Array(9);
            let n = 0;
            for (let i = 0; i < 4; i++) {
                if (i === row) {
                    continue;
                }
                for (let j = 0; j < 4; j++) {
                    if (j === col) {
                        continue;
                    }
                    v[n] = a[i][j];
                    n++;
                }
            }
            return matrix3_from_array(v);
        }

        function minor(a, row, col) {
            const m = submatrix(a, row, col);
            return matrix3_determinant(m);
        }

        function cofactor(a, row, col) {
            if ((row + col) % 2 === 0) {
                return minor(a, row, col);
            } else {
                return -minor(a, row, col);
            }
        }

        function determinant(a) {
            let det = 0;
            for (let i = 0; i < 4; i++) {
                det += a[0][i] * cofactor(a, 0, i);
            }
            return det;
        }

        function inverse(a) {
            // ottimizziamo calcolando una sola volta in determinante
            //if !self.is_invertible() {
            //    return None;
            // }
            const det = determinant(a);
            if (det === 0) {
                return null;
            }
            const m = matrix();
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    let c = cofactor(a, row, col);
                    //console.log("c=",c);
                    m[col][row] = c / det;
                }
            }
            return m;
        }


        function matrix3() {
            return [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
        }

        function matrix3_from_array(a) {
            return [[a[0], a[1], a[2]], [a[3], a[4], a[5]], [a[6], a[7], a[8]]];

        }

        function matrix3_submatrix(a, row, col) {
            const v = Array(4);
            let n = 0;
            for (let i = 0; i < 3; i++) {
                if (i === row) {
                    continue;
                }
                for (let j = 0; j < 3; j++) {
                    if (j === col) {
                        continue;
                    }
                    v[n] = a[i][j];
                    n += 1;
                }
            }
            return matrix2_from_array(v);
        }



        function matrix3_minor(a, row, col) {
            const m = matrix3_submatrix(a, row, col);
            return matrix2_determinant(m);
        }
        function matrix3_cofactor(a, row, col) {
            if ((row + col) % 2 == 0) {
                return matrix3_minor(a, row, col);
            } else {
                return -matrix3_minor(a, row, col);
            }
        }
        function matrix3_determinant(a) {
            let det = 0;
            for (let i = 0; i < 3; i++) {
                det += a[0][i] * matrix3_cofactor(a, 0, i);
            }
            return det;
        }

        function matrix2() {
            return [[0.0, 0.0], [0.0, 0.0]];
        }
        function matrix2_from_array(a) {
            return [[a[0], a[1]], [a[2], a[3]]];
        }

        function matrix2_determinant(a) {
            return a[0][0] * a[1][1] - a[0][1] * a[1][0];
        }


        /************************* RAY ***********************************/



        function ray(origin, direction) {
            return { origin, direction };
        }

        function position(ray, t) {
            return add_tuple(ray.origin, multiply_tuple(ray.direction, t));
        }



        function transform(ray, m) {
            return ray(matrix_mul_tuple(m, ray.origin), matrix_mul_tuple(m, ray.direction));

        }








        /********************************************************************/

        let a = matrix_from_array([-5, 2, 6, -8,
            1, -5, 1, 8,
            7, 7, -6, -7,
            1, -3, 7, 4]);

        let b = inverse(a);
        let det = determinant(a);
        console.log(b);
        console.log(det);
        console.log(cofactor(a, 2, 3));

        const c = init_canvas("#canvas", 360, 240);
        console.log(c);
        for (let i = 0; i < 100; i++) {
            draw_pixel(c, i, i, color(0.9, 0.9, 0));
        }
        update_canvas(c);

        /**********************************************************************************/
        /*                                     TEST                                       */
        /**********************************************************************************/
        {
            let a = tuple(4.3, -4.2, 3.1, 1.0);
            chai.assert.equal(a.x, 4.3);
            chai.assert.equal(a.y, -4.2);
            chai.assert.equal(a.z, 3.1);
            chai.assert.equal(a.w, 1.0);
            let p = point(4, -4, 3);
            chai.assert.deepEqual(p, tuple(4, -4, 3, 1));
            let v = vector(4, -4, 3);
            chai.assert.deepEqual(v, tuple(4, -4, 3, 0));
            v = vector(-1, -2, -3);
            chai.assert.equal(magnitude(v), Math.sqrt(14));
            let n = normalize(v);
            chai.assert.equal(n.x, -1 / Math.sqrt(14));
            chai.assert.equal(n.y, -2 / Math.sqrt(14));
            chai.assert.equal(n.z, -3 / Math.sqrt(14));
            a = vector(1, 2, 3)
            let b = vector(2, 3, 4)
            chai.assert.equal(dot(a, b), 20);
            chai.assert.deepEqual(cross(a, b), vector(-1, 2, -1));
            chai.assert.deepEqual(cross(b, a), vector(1, -2, 1));
        }



    </script>

</body>

</html>
